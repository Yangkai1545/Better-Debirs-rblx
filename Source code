-- BetterDebris.lua

local RunService = game:GetService("RunService")
local CollectionService = game:GetService("CollectionService")

-- Constants
local CONSTANTS = {
	GROUP_ID_MIN = 100000,
	GROUP_ID_MAX = 999999,
	AUTO_CLEANUP_INTERVAL = 600, -- 10 minutes in seconds
	DEFAULT_CLEANUP_LIFETIME = 5, -- seconds
	MIN_LIFETIME = 0.01, -- minimum allowed lifetime in seconds
	GROUP_ID_SEPARATOR = "_", -- separator between random number and timestamp
}

-- BetterDebris singleton class
local BetterDebris = {}
BetterDebris.__index = BetterDebris

-- Private state for the singleton instance
local _instance = nil
local _state = {
	items = {},
	groups = {},
	isDestroyed = false,
	autoCleanupEnabled = false,
	heartbeatConnection = nil,
	autoCleanupTask = nil,
}

-- Validation helper functions
local function validateInstance(item)
	return typeof(item) == "Instance" and item:IsDescendantOf(game)
end

local function validateGroupItems(items)
	if typeof(items) ~= "table" then
		return false, "Items must be a table"
	end
	
	local validCount = 0
	for _, item in ipairs(items) do
		if validateInstance(item) then
			validCount += 1
		end
	end
	
	if validCount == 0 then
		return false, "No valid instances found in the group"
	end
	
	return true, nil, validCount
end

-- Helper function to generate a unique group ID
-- Format: {RandomNumber}_{Timestamp} - ensures uniqueness across time and prevents collisions
local function generateGroupId()
	local randomPart = tostring(math.random(CONSTANTS.GROUP_ID_MIN, CONSTANTS.GROUP_ID_MAX))
	local timestampPart = tostring(tick())
	return randomPart .. CONSTANTS.GROUP_ID_SEPARATOR .. timestampPart
end

-- Helper function to create and register a debris group
local function createDebrisGroup(items, lifetime, callback, groupId)
	local actualCount = 0
	
	for _, instance in ipairs(items) do
		if validateInstance(instance) then
			_state.items[instance] = {
				StartTime = tick(),
				Lifetime = lifetime,
				Callback = nil, -- disable per-item callback for group items
				Paused = false,
				GroupId = groupId,
			}
			actualCount += 1
		end
	end

	if actualCount > 0 then
		_state.groups[groupId] = {
			Items = items,
			Remaining = actualCount,
			Callback = callback,
		}
		return true, actualCount
	end
	
	return false, 0
end

-- Helper function to safely call a function and log errors
local function safeCall(func, ...)
	local success, error = pcall(func, ...)
	if not success then
		warn("BetterDebris: Error during callback execution - " .. tostring(error))
	end
	return success
end

-- Helper function to safely destroy an instance
local function safeDestroy(item)
	if not item or not item:IsDescendantOf(game) then
		return false
	end
	
	local success, error = pcall(function() 
		item:Destroy() 
	end)
	
	if not success then
		warn("BetterDebris: Failed to destroy item " .. tostring(item) .. " - " .. tostring(error))
		-- Fallback: try to remove from parent if destroy fails
		pcall(function()
			if item.Parent then
				item.Parent = nil
			end
		end)
	end
	
	return success
end

-- Helper function to destroy individual instances with explicit state modifications
-- Side effects: 
-- - Removes item from _state.items
-- - Decrements group remaining count if item belongs to a group
-- - Removes group from _state.groups if no items remain
-- - Executes callbacks for item and/or group completion
local function destroyItem(item, data)
	-- Attempt to destroy the instance safely
	if item then
		safeDestroy(item)
	end
	
	-- Execute item callback if present
	if data.Callback then
		safeCall(data.Callback, item)
	end
	
	-- Remove item from tracking (explicit state modification)
	_state.items[item] = nil

	-- Handle group lifecycle if item belongs to a group
	if data.GroupId then
		local group = _state.groups[data.GroupId]
		if group then
			group.Remaining -= 1
			if group.Remaining <= 0 then
				-- Execute group completion callback
				if group.Callback then
					safeCall(group.Callback, group.Items)
				end
				-- Remove completed group from tracking (explicit state modification)
				_state.groups[data.GroupId] = nil
			end
		end
	end
end

-- Helper function to collect expired items
local function collectExpiredItems(currentTime)
	local expiredItems = {}
	
	for item, data in pairs(_state.items) do
		if not item or not item:IsDescendantOf(game) then
			table.insert(expiredItems, {item = item, data = data, reason = "invalid"})
		elseif not data.Paused then
			local elapsed = currentTime - data.StartTime
			if elapsed >= data.Lifetime then
				table.insert(expiredItems, {item = item, data = data, reason = "expired"})
			end
		end
	end
	
	return expiredItems
end

-- Helper function to remove expired items
local function removeExpiredItems(expiredItems)
	for _, expiredItem in ipairs(expiredItems) do
		destroyItem(expiredItem.item, expiredItem.data)
	end
end

-- Main processing loop (split into smaller functions)
local function processItems()
	if _state.isDestroyed then
		return
	end
	
	local currentTime = tick()
	local expiredItems = collectExpiredItems(currentTime)
	removeExpiredItems(expiredItems)
end

-- Singleton constructor
function BetterDebris.new()
	if _instance then
		return _instance
	end
	
	_instance = setmetatable({}, BetterDebris)
	return _instance
end

-- Get the singleton instance
function BetterDebris.getInstance()
	return _instance or BetterDebris.new()
end

-- Initialize the debris system
function BetterDebris:Initialize(config)
	config = config or {}
	
	if _state.heartbeatConnection then
		return self -- Already initialized
	end
	
	-- Start the main processing loop
	_state.heartbeatConnection = RunService.Heartbeat:Connect(processItems)
	
	-- Enable auto-cleanup if requested
	if config.enableAutoCleanup then
		self:EnableAutoCleanup()
	end
	
	return self
end

-- Add single instance with improved error handling
function BetterDebris:Add(item: Instance, lifetime: number, callback: ((Instance) -> ())?)
	if typeof(item) ~= "Instance" then
		warn("BetterDebris:Add - Item must be an Instance, got " .. typeof(item))
		return false
	end
	
	if typeof(lifetime) ~= "number" or lifetime < CONSTANTS.MIN_LIFETIME then
		warn("BetterDebris:Add - Lifetime must be at least " .. CONSTANTS.MIN_LIFETIME .. " seconds, got " .. tostring(lifetime))
		return false
	end
	
	if _state.isDestroyed then
		warn("BetterDebris:Add - Cannot add items to destroyed debris system")
		return false
	end
	
	self:Cancel(item)

	_state.items[item] = {
		StartTime = tick(),
		Lifetime = lifetime,
		Callback = callback,
		Paused = false,
	}
	
	return true
end

-- Add group of instances with extracted validation and creation logic
function BetterDebris:AddGroup(items: {Instance}, lifetime: number, callback: (({Instance}) -> ())?)
	-- Validate input parameters
	local isValid, errorMessage, validCount = validateGroupItems(items)
	if not isValid then
		warn("BetterDebris:AddGroup - " .. errorMessage)
		return false
	end
	
	if typeof(lifetime) ~= "number" or lifetime < CONSTANTS.MIN_LIFETIME then
		warn("BetterDebris:AddGroup - Lifetime must be at least " .. CONSTANTS.MIN_LIFETIME .. " seconds, got " .. tostring(lifetime))
		return false
	end
	
	if _state.isDestroyed then
		warn("BetterDebris:AddGroup - Cannot add items to destroyed debris system")
		return false
	end

	-- Create the debris group using helper function
	local groupId = generateGroupId()
	local success, actualCount = createDebrisGroup(items, lifetime, callback, groupId)
	
	return success
end

function BetterDebris:Cancel(item: Instance)
	_state.items[item] = nil
end

function BetterDebris:Pause(item: Instance)
	local data = _state.items[item]
	if data and not data.Paused then
		data.Paused = true
		data.Remaining = data.Lifetime - (tick() - data.StartTime)
	end
end

function BetterDebris:Resume(item: Instance)
	local data = _state.items[item]
	if data and data.Paused then
		data.Paused = false
		data.StartTime = tick() - (data.Lifetime - data.Remaining)
		data.Remaining = nil
	end
end

function BetterDebris:ClearAll()
	for item, data in pairs(_state.items) do
		destroyItem(item, data)
	end
end

function BetterDebris:GetTrackedCount(): number
	local count = 0
	for _ in pairs(_state.items) do
		count += 1
	end
	return count
end

-- Cleanup all tagged instances with improved variable naming
function BetterDebris:CleanupAllTagged(tagName: string, lifetime: number?)
	if typeof(tagName) ~= "string" then
		warn("BetterDebris:CleanupAllTagged - Tag name must be a string, got " .. typeof(tagName))
		return false
	end
	
	local lifetimeToUse = lifetime or CONSTANTS.DEFAULT_CLEANUP_LIFETIME

	local taggedInstances = CollectionService:GetTagged(tagName)
	for _, instance in ipairs(taggedInstances) do
		if instance:IsA("Instance") and instance:IsDescendantOf(game) then
			self:Add(instance, lifetimeToUse)
		end
	end
	
	return true
end

-- Enable auto-cleanup system (opt-in)
function BetterDebris:EnableAutoCleanup()
	if _state.autoCleanupEnabled then
		return self
	end
	
	_state.autoCleanupEnabled = true
	_state.autoCleanupTask = task.spawn(function()
		while _state.autoCleanupEnabled and not _state.isDestroyed do
			task.wait(CONSTANTS.AUTO_CLEANUP_INTERVAL)
			if _state.autoCleanupEnabled and not _state.isDestroyed then
				self:CleanupAllTagged("CanDisappear", CONSTANTS.DEFAULT_CLEANUP_LIFETIME)
			end
		end
	end)
	
	return self
end

-- Disable auto-cleanup system
function BetterDebris:DisableAutoCleanup()
	_state.autoCleanupEnabled = false
	if _state.autoCleanupTask then
		task.cancel(_state.autoCleanupTask)
		_state.autoCleanupTask = nil
	end
	return self
end

-- Destroy the debris system
function BetterDebris:Destroy()
	_state.isDestroyed = true
	
	if _state.heartbeatConnection then
		_state.heartbeatConnection:Disconnect()
		_state.heartbeatConnection = nil
	end
	
	self:DisableAutoCleanup()
	self:ClearAll()
	
	_instance = nil
end

-- Create and return the singleton instance
local debrisInstance = BetterDebris.new()

-- Auto-initialize with basic setup (backwards compatibility)
debrisInstance:Initialize()

return debrisInstance
