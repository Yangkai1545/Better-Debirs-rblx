-- BetterDebris.lua

local RunService = game:GetService("RunService")
local CollectionService = game:GetService("CollectionService")

-- Constants
local CONSTANTS = {
	GROUP_ID_MIN = 100000,
	GROUP_ID_MAX = 999999,
	AUTO_CLEANUP_INTERVAL = 600, -- 10 minutes
	DEFAULT_CLEANUP_LIFETIME = 5,
	MIN_LIFETIME = 0.01, -- Minimum allowed lifetime in seconds to avoid zero/negative values
}

-- BetterDebris singleton class
local BetterDebris = {}
BetterDebris.__index = BetterDebris

-- Private state for the singleton instance
local _instance = nil
local _state = {
	items = {},
	groups = {},
	isDestroyed = false,
	autoCleanupEnabled = false,
	heartbeatConnection = nil,
	autoCleanupTask = nil,
}

-- Validation helper functions
local function validateInstance(item)
	return typeof(item) == "Instance" and item:IsDescendantOf(game)
end

local function validateGroupItems(items)
	if typeof(items) ~= "table" then
		return false, "Items must be a table"
	end
	
	local validCount = 0
	for _, item in ipairs(items) do
		if validateInstance(item) then
			validCount += 1
		end
	end
	
	if validCount == 0 then
		return false, "No valid instances found in the group"
	end
	
	return true, nil, validCount
end

-- Helper function to generate unique group IDs
-- Format: {random_number}_{timestamp}
-- This ensures uniqueness across time and reduces collision probability
local function generateGroupId()
	return tostring(math.random(CONSTANTS.GROUP_ID_MIN, CONSTANTS.GROUP_ID_MAX)) .. "_" .. tick()
end

-- Helper function to create a group and add valid instances to tracking
-- Returns the number of items actually added to the group
local function createGroupFromItems(items, lifetime, groupId)
	local actualCount = 0
	local currentTime = tick()

	for _, instance in ipairs(items) do
		if validateInstance(instance) then
			_state.items[instance] = {
				StartTime = currentTime,
				Lifetime = lifetime,
				Callback = nil, -- disable per-item callback for group items
				Paused = false,
				GroupId = groupId,
			}
			actualCount += 1
		end
	end

	return actualCount
end

-- Helper function to destroy individual instances and manage state
-- Side effects:
-- 1. Destroys the instance using item:Destroy()
-- 2. Executes per-item callback if provided
-- 3. Removes item from _state.items tracking table
-- 4. Updates group state if item belongs to a group
-- 5. Executes group callback and cleans up group when all items are processed
local function destroyItem(item, data)
	if item and item:IsDescendantOf(game) then
		local success, errorMessage = pcall(function() item:Destroy() end)
		if not success then
			warn("BetterDebris: Failed to destroy item " .. tostring(item) .. ": " .. tostring(errorMessage))
		end
	end
	if data.Callback then
		local success, errorMessage = pcall(data.Callback, item)
		if not success then
			warn("BetterDebris: Callback execution failed for item " .. tostring(item) .. ": " .. tostring(errorMessage))
		end
	end
	
	-- Remove item from tracking (explicit state modification)
	_state.items[item] = nil

	-- Handle group state updates if item belongs to a group
	if data.GroupId then
		local group = _state.groups[data.GroupId]
		if group then
			group.Remaining -= 1
			if group.Remaining <= 0 then
				if group.Callback then
					local success, errorMessage = pcall(group.Callback, group.Items)
					if not success then
						warn("BetterDebris: Group callback execution failed for group " .. tostring(data.GroupId) .. ": " .. tostring(errorMessage))
					end
				end
				-- Clean up completed group (explicit state modification)
				_state.groups[data.GroupId] = nil
			end
		end
	end
end

-- Helper function to collect expired items
local function collectExpiredItems(currentTime)
	local expiredItems = {}
	
	for item, data in pairs(_state.items) do
		if not item or not item:IsDescendantOf(game) then
			table.insert(expiredItems, {item = item, data = data, reason = "invalid"})
		elseif not data.Paused then
			local elapsed = currentTime - data.StartTime
			if elapsed >= data.Lifetime then
				table.insert(expiredItems, {item = item, data = data, reason = "expired"})
			end
		end
	end
	
	return expiredItems
end

-- Helper function to remove expired items
local function removeExpiredItems(expiredItems)
	for _, expiredItem in ipairs(expiredItems) do
		destroyItem(expiredItem.item, expiredItem.data)
	end
end

-- Main processing loop (split into smaller functions)
local function processItems()
	if _state.isDestroyed then
		return
	end
	
	local currentTime = tick()
	local expiredItems = collectExpiredItems(currentTime)
	removeExpiredItems(expiredItems)
end

-- Singleton constructor
function BetterDebris.new()
	if _instance then
		return _instance
	end
	
	_instance = setmetatable({}, BetterDebris)
	return _instance
end

-- Get the singleton instance
function BetterDebris.getInstance()
	return _instance or BetterDebris.new()
end

-- Initialize the debris system
function BetterDebris:Initialize(config)
	config = config or {}
	
	if _state.heartbeatConnection then
		return self -- Already initialized
	end
	
	-- Start the main processing loop
	_state.heartbeatConnection = RunService.Heartbeat:Connect(processItems)
	
	-- Enable auto-cleanup if requested
	if config.enableAutoCleanup then
		self:EnableAutoCleanup()
	end
	
	return self
end

-- Add single instance with improved error handling
function BetterDebris:Add(item: Instance, lifetime: number, callback: ((Instance) -> ())?)
	if typeof(item) ~= "Instance" then
		warn("BetterDebris:Add - Item must be an Instance, got " .. typeof(item))
		return false
	end
	
	if typeof(lifetime) ~= "number" or lifetime < CONSTANTS.MIN_LIFETIME then
		warn("BetterDebris:Add - Lifetime must be a positive number >= " .. CONSTANTS.MIN_LIFETIME .. ", got " .. tostring(lifetime))
		return false
	end
	
	if _state.isDestroyed then
		warn("BetterDebris:Add - Cannot add items to destroyed debris system")
		return false
	end
	
	self:Cancel(item)

	_state.items[item] = {
		StartTime = tick(),
		Lifetime = lifetime,
		Callback = callback,
		Paused = false,
	}
	
	return true
end

-- Add group of instances with extracted validation
function BetterDebris:AddGroup(items: {Instance}, lifetime: number, callback: (({Instance}) -> ())?)
	local isValid, errorMessage, validCount = validateGroupItems(items)
	if not isValid then
		warn("BetterDebris:AddGroup - " .. errorMessage)
		return false
	end
	
	if typeof(lifetime) ~= "number" or lifetime < CONSTANTS.MIN_LIFETIME then
		warn("BetterDebris:AddGroup - Lifetime must be a positive number >= " .. CONSTANTS.MIN_LIFETIME .. ", got " .. tostring(lifetime))
		return false
	end
	
	if _state.isDestroyed then
		warn("BetterDebris:AddGroup - Cannot add items to destroyed debris system")
		return false
	end

	-- Generate unique group ID using helper function
	local groupId = generateGroupId()
	
	-- Create group and add valid instances to tracking
	local actualCount = createGroupFromItems(items, lifetime, groupId)

	if actualCount > 0 then
		-- Register the group for tracking
		_state.groups[groupId] = {
			Items = items,
			Remaining = actualCount,
			Callback = callback,
		}
		return true
	end
	
	return false
end

function BetterDebris:Cancel(item: Instance)
	_state.items[item] = nil
end

function BetterDebris:Pause(item: Instance)
	local data = _state.items[item]
	if data and not data.Paused then
		data.Paused = true
		data.Remaining = data.Lifetime - (tick() - data.StartTime)
	end
end

function BetterDebris:Resume(item: Instance)
	local data = _state.items[item]
	if data and data.Paused then
		data.Paused = false
		data.StartTime = tick() - (data.Lifetime - data.Remaining)
		data.Remaining = nil
	end
end

function BetterDebris:ClearAll()
	for item, data in pairs(_state.items) do
		destroyItem(item, data)
	end
end

function BetterDebris:GetTrackedCount(): number
	local count = 0
	for _ in pairs(_state.items) do
		count += 1
	end
	return count
end

-- Cleanup all tagged instances with improved variable naming
function BetterDebris:CleanupAllTagged(tagName: string, lifetime: number?)
	if typeof(tagName) ~= "string" then
		warn("BetterDebris:CleanupAllTagged - Tag name must be a string, got " .. typeof(tagName))
		return false
	end
	
	local lifetimeToUse = lifetime or CONSTANTS.DEFAULT_CLEANUP_LIFETIME

	local taggedInstances = CollectionService:GetTagged(tagName)
	for _, instance in ipairs(taggedInstances) do
		if instance:IsA("Instance") and instance:IsDescendantOf(game) then
			self:Add(instance, lifetimeToUse)
		end
	end
	
	return true
end

-- Enable auto-cleanup system (opt-in)
function BetterDebris:EnableAutoCleanup()
	if _state.autoCleanupEnabled then
		return self
	end
	
	_state.autoCleanupEnabled = true
	_state.autoCleanupTask = task.spawn(function()
		while _state.autoCleanupEnabled and not _state.isDestroyed do
			task.wait(CONSTANTS.AUTO_CLEANUP_INTERVAL)
			if _state.autoCleanupEnabled and not _state.isDestroyed then
				self:CleanupAllTagged("CanDisappear", CONSTANTS.DEFAULT_CLEANUP_LIFETIME)
			end
		end
	end)
	
	return self
end

-- Disable auto-cleanup system
function BetterDebris:DisableAutoCleanup()
	_state.autoCleanupEnabled = false
	if _state.autoCleanupTask then
		task.cancel(_state.autoCleanupTask)
		_state.autoCleanupTask = nil
	end
	return self
end

-- Destroy the debris system
function BetterDebris:Destroy()
	_state.isDestroyed = true
	
	if _state.heartbeatConnection then
		_state.heartbeatConnection:Disconnect()
		_state.heartbeatConnection = nil
	end
	
	self:DisableAutoCleanup()
	self:ClearAll()
	
	_instance = nil
end

-- Create and return the singleton instance
local debrisInstance = BetterDebris.new()

-- Auto-initialize with basic setup (backwards compatibility)
debrisInstance:Initialize()

return debrisInstance
